{"version":3,"sources":["Pager.tsx"],"names":["React","StyleSheet","TextInput","Keyboard","I18nManager","InteractionManager","PanGestureHandler","State","Animated","Easing","memoize","Clock","Value","onChange","and","or","abs","add","block","call","ceil","clockRunning","cond","divide","eq","event","floor","greaterThan","lessThan","max","min","multiply","neq","not","round","set","spring","startClock","stopClock","sub","timing","PagerContext","createContext","TRUE","FALSE","NOOP","UNSET","DIRECTION_LEFT","DIRECTION_RIGHT","SWIPE_DISTANCE_MINIMUM","SWIPE_VELOCITY_IMPACT","SPRING_CONFIG","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","SPRING_VELOCITY_SCALE","TIMING_CONFIG","duration","easing","out","cubic","Pager","state","enabled","childPanGestureHandlerRefs","providerVal","addGestureHandlerRef","ref","includes","setState","prevState","gestureHandlerRef","createRef","clock","velocityX","gestureX","gestureState","UNDETERMINED","offsetX","gesturesEnabled","progress","props","navigationState","index","layout","width","nextIndex","lastEnteredIndex","isSwiping","isSwipeGesture","indexAtSwipeEnd","routesLength","routes","length","layoutWidth","swipeVelocityImpact","undefined","springVelocityScale","position","springConfig","timingConfig","initialVelocityForSpring","currentIndexValue","pendingIndexValue","previouslyFocusedTextInput","enterListeners","interactionHandle","jumpToIndex","setValue","jumpTo","key","keyboardDismissMode","onIndexChange","findIndex","route","dismiss","addListener","type","listener","push","removeListener","indexOf","splice","handleEnteredIndexChange","value","Math","forEach","transitionTo","toValue","frameTime","time","finished","isRTL","velocity","handleGestureEvent","nativeEvent","translationX","extrapolatedPosition","toggleEnabled","maybeCancel","translateX","forceUpdate","currentIndex","onSwipeStart","onSwipeEnd","createInteractionHandle","input","currentlyFocusedField","blurTextInput","clearInteractionHandle","focusTextInput","ACTIVE","getTranslateX","context","prevProps","swipeEnabled","children","removeClippedSubviews","gestureHandlerProps","render","styles","container","transform","Component","defaultProps","contextType","create","flex","flexDirection"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  StyleSheet,\n  TextInput,\n  Keyboard,\n  I18nManager,\n  InteractionManager,\n} from 'react-native';\nimport { PanGestureHandler, State } from 'react-native-gesture-handler';\nimport Animated, { Easing } from 'react-native-reanimated';\nimport memoize from './memoize';\n\nimport {\n  Layout,\n  NavigationState,\n  Route,\n  Listener,\n  PagerCommonProps,\n  EventEmitterProps,\n} from './types';\n\ntype Binary = 0 | 1;\n\nexport type Props<T extends Route> = PagerCommonProps & {\n  onIndexChange: (index: number) => void;\n  navigationState: NavigationState<T>;\n  layout: Layout;\n  // Clip unfocused views to improve memory usage\n  // Don't enable this on iOS where this is buggy and views don't re-appear\n  removeClippedSubviews?: boolean;\n  children: (\n    props: EventEmitterProps & {\n      // Animated value which represents the state of current index\n      // It can include fractional digits as it represents the intermediate value\n      position: Animated.Node<number>;\n      // Function to actually render the content of the pager\n      // The parent component takes care of rendering\n      render: (children: React.ReactNode) => React.ReactNode;\n      // Callback to call when switching the tab\n      // The tab switch animation is performed even if the index in state is unchanged\n      jumpTo: (key: string) => void;\n    }\n  ) => React.ReactNode;\n  gestureHandlerProps: React.ComponentProps<typeof PanGestureHandler>;\n};\n\ntype ComponentState = {\n  enabled: boolean;\n  childPanGestureHandlerRefs: React.RefObject<PanGestureHandler>[];\n};\n\nconst {\n  Clock,\n  Value,\n  onChange,\n  and,\n  or,\n  abs,\n  add,\n  block,\n  call,\n  ceil,\n  clockRunning,\n  cond,\n  divide,\n  eq,\n  event,\n  floor,\n  greaterThan,\n  lessThan,\n  max,\n  min,\n  multiply,\n  neq,\n  not,\n  round,\n  set,\n  spring,\n  startClock,\n  stopClock,\n  sub,\n  timing,\n} = Animated;\n\nconst PagerContext = React.createContext({});\n\nconst TRUE = 1;\nconst FALSE = 0;\nconst NOOP = 0;\nconst UNSET = -1;\n\nconst DIRECTION_LEFT = 1;\nconst DIRECTION_RIGHT = -1;\n\nconst SWIPE_DISTANCE_MINIMUM = 20;\n\nconst SWIPE_VELOCITY_IMPACT = 0.2;\n\nconst SPRING_CONFIG = {\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: true,\n  restDisplacementThreshold: 0.01,\n  restSpeedThreshold: 0.01,\n};\n\nconst SPRING_VELOCITY_SCALE = 1;\n\nconst TIMING_CONFIG = {\n  duration: 200,\n  easing: Easing.out(Easing.cubic),\n};\n\nexport default class Pager<T extends Route> extends React.Component<\n  Props<T>,\n  ComponentState\n> {\n  static defaultProps = {\n    swipeVelocityImpact: SWIPE_VELOCITY_IMPACT,\n    springVelocityScale: SPRING_VELOCITY_SCALE,\n  };\n\n  state = {\n    enabled: true,\n    childPanGestureHandlerRefs: [] as React.RefObject<PanGestureHandler>[],\n  };\n\n  componentDidMount() {\n    // Register this PanGestureHandler with the parent (if parent exists)\n    // in order to coordinate gestures between handlers.\n    if (this.context && this.context.addGestureHandlerRef) {\n      this.context.addGestureHandlerRef(this.gestureHandlerRef);\n    }\n  }\n\n  componentDidUpdate(prevProps: Props<T>) {\n    const {\n      navigationState,\n      layout,\n      swipeVelocityImpact,\n      springVelocityScale,\n      springConfig,\n      timingConfig,\n    } = this.props;\n    const { index, routes } = navigationState;\n\n    if (\n      // Check for index in state to avoid unintended transition if component updates during swipe\n      (index !== prevProps.navigationState.index &&\n        index !== this.currentIndexValue) ||\n      // Check if the user updated the index correctly after an update\n      (typeof this.pendingIndexValue === 'number' &&\n        index !== this.pendingIndexValue)\n    ) {\n      // Index in user's state is different from the index being tracked\n      this.jumpToIndex(index);\n    }\n\n    // Reset the pending index\n    this.pendingIndexValue = undefined;\n\n    // Update our mappings of animated nodes when props change\n    if (prevProps.navigationState.routes.length !== routes.length) {\n      this.routesLength.setValue(routes.length);\n    }\n\n    if (prevProps.layout.width !== layout.width) {\n      this.progress.setValue(-index * layout.width);\n      this.layoutWidth.setValue(layout.width);\n    }\n\n    if (prevProps.swipeVelocityImpact !== swipeVelocityImpact) {\n      this.swipeVelocityImpact.setValue(\n        swipeVelocityImpact !== undefined\n          ? swipeVelocityImpact\n          : SWIPE_VELOCITY_IMPACT\n      );\n    }\n\n    if (prevProps.springVelocityScale !== springVelocityScale) {\n      this.springVelocityScale.setValue(\n        springVelocityScale !== undefined\n          ? springVelocityScale\n          : SPRING_VELOCITY_SCALE\n      );\n    }\n\n    if (prevProps.springConfig !== springConfig) {\n      this.springConfig.damping.setValue(\n        springConfig.damping !== undefined\n          ? springConfig.damping\n          : SPRING_CONFIG.damping\n      );\n\n      this.springConfig.mass.setValue(\n        springConfig.mass !== undefined ? springConfig.mass : SPRING_CONFIG.mass\n      );\n\n      this.springConfig.stiffness.setValue(\n        springConfig.stiffness !== undefined\n          ? springConfig.stiffness\n          : SPRING_CONFIG.stiffness\n      );\n\n      this.springConfig.restSpeedThreshold.setValue(\n        springConfig.restSpeedThreshold !== undefined\n          ? springConfig.restSpeedThreshold\n          : SPRING_CONFIG.restSpeedThreshold\n      );\n\n      this.springConfig.restDisplacementThreshold.setValue(\n        springConfig.restDisplacementThreshold !== undefined\n          ? springConfig.restDisplacementThreshold\n          : SPRING_CONFIG.restDisplacementThreshold\n      );\n    }\n\n    if (prevProps.timingConfig !== timingConfig) {\n      this.timingConfig.duration.setValue(\n        timingConfig.duration !== undefined\n          ? timingConfig.duration\n          : TIMING_CONFIG.duration\n      );\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.interactionHandle !== null) {\n      InteractionManager.clearInteractionHandle(this.interactionHandle);\n    }\n  }\n\n  static contextType = PagerContext;\n\n  // Mechanism to add child PanGestureHandler refs in the case that this\n  // Pager is a parent to child Pagers. Allows for coordination between handlers\n  private providerVal = {\n    addGestureHandlerRef: (ref: React.RefObject<PanGestureHandler>) => {\n      if (!this.state.childPanGestureHandlerRefs.includes(ref)) {\n        this.setState((prevState: ComponentState) => ({\n          childPanGestureHandlerRefs: [\n            ...prevState.childPanGestureHandlerRefs,\n            ref,\n          ],\n        }));\n      }\n    },\n  };\n\n  // PanGestureHandler ref used for coordination with parent handlers\n  private gestureHandlerRef: React.RefObject<\n    PanGestureHandler\n  > = React.createRef();\n\n  // Clock used for tab transition animations\n  private clock = new Clock();\n\n  // Current state of the gesture\n  private velocityX = new Value(0);\n  private gestureX = new Value(0);\n  private gestureState = new Value(State.UNDETERMINED);\n  private offsetX = new Value(0);\n\n  // Tracks current state of gesture handler enabled\n  private gesturesEnabled = new Value(1);\n\n  // Current progress of the page (translateX value)\n  private progress = new Value(\n    // Initial value is based on the index and page width\n    this.props.navigationState.index * this.props.layout.width * DIRECTION_RIGHT\n  );\n\n  // Initial index of the tabs\n  private index = new Value(this.props.navigationState.index);\n\n  // Next index of the tabs, updated for navigation from outside (tab press, state update)\n  private nextIndex: Animated.Value<number> = new Value(UNSET);\n\n  // Scene that was last entered\n  private lastEnteredIndex = new Value(this.props.navigationState.index);\n\n  // Whether the user is currently dragging the screen\n  private isSwiping: Animated.Value<Binary> = new Value(FALSE);\n\n  // Whether the update was due to swipe gesture\n  // This controls whether the transition will use a spring or timing animation\n  // Remember to set it before transition needs to occur\n  private isSwipeGesture: Animated.Value<Binary> = new Value(FALSE);\n\n  // Track the index value when a swipe gesture has ended\n  // This lets us know if a gesture end triggered a tab switch or not\n  private indexAtSwipeEnd: Animated.Value<number> = new Value(\n    this.props.navigationState.index\n  );\n\n  // Mappings to some prop values\n  // We use them in animation calculations, so we need live animated nodes\n  private routesLength = new Value(this.props.navigationState.routes.length);\n  private layoutWidth = new Value(this.props.layout.width);\n\n  // Determines how relevant is a velocity while calculating next position while swiping\n  private swipeVelocityImpact = new Value(\n    this.props.swipeVelocityImpact !== undefined\n      ? this.props.swipeVelocityImpact\n      : SWIPE_VELOCITY_IMPACT\n  );\n\n  private springVelocityScale = new Value(\n    this.props.springVelocityScale !== undefined\n      ? this.props.springVelocityScale\n      : SPRING_VELOCITY_SCALE\n  );\n\n  // The position value represent the position of the pager on a scale of 0 - routes.length-1\n  // It is calculated based on the translate value and layout width\n  // If we don't have the layout yet, we should return the current index\n  private position = cond(\n    this.layoutWidth,\n    divide(multiply(this.progress, -1), this.layoutWidth),\n    this.index\n  );\n\n  // Animation configuration\n  private springConfig = {\n    damping: new Value(\n      this.props.springConfig.damping !== undefined\n        ? this.props.springConfig.damping\n        : SPRING_CONFIG.damping\n    ),\n    mass: new Value(\n      this.props.springConfig.mass !== undefined\n        ? this.props.springConfig.mass\n        : SPRING_CONFIG.mass\n    ),\n    stiffness: new Value(\n      this.props.springConfig.stiffness !== undefined\n        ? this.props.springConfig.stiffness\n        : SPRING_CONFIG.stiffness\n    ),\n    restSpeedThreshold: new Value(\n      this.props.springConfig.restSpeedThreshold !== undefined\n        ? this.props.springConfig.restSpeedThreshold\n        : SPRING_CONFIG.restSpeedThreshold\n    ),\n    restDisplacementThreshold: new Value(\n      this.props.springConfig.restDisplacementThreshold !== undefined\n        ? this.props.springConfig.restDisplacementThreshold\n        : SPRING_CONFIG.restDisplacementThreshold\n    ),\n  };\n\n  private timingConfig = {\n    duration: new Value(\n      this.props.timingConfig.duration !== undefined\n        ? this.props.timingConfig.duration\n        : TIMING_CONFIG.duration\n    ),\n  };\n\n  // The reason for using this value instead of simply passing `this._velocity`\n  // into a spring animation is that we need to reverse it if we're using RTL mode.\n  // Also, it's not possible to pass multiplied value there, because\n  // value passed to STATE of spring (the first argument) has to be Animated.Value\n  // and it's not allowed to pass other nodes there. The result of multiplying is not an\n  // Animated.Value. So this value is being updated on each start of spring animation.\n  private initialVelocityForSpring = new Value(0);\n\n  // The current index change caused by the pager's animation\n  // The pager is used as a controlled component\n  // We need to keep track of the index to determine when to trigger animation\n  // The state will change at various points, we should only respond when we are out of sync\n  // This will ensure smoother animation and avoid weird glitches\n  private currentIndexValue = this.props.navigationState.index;\n\n  // The pending index value as result of state update caused by swipe gesture\n  // We need to set it when state changes from inside this component\n  // It also needs to be reset right after componentDidUpdate fires\n  private pendingIndexValue: number | undefined = undefined;\n\n  // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n  private previouslyFocusedTextInput: number | null = null;\n\n  // Listeners for the entered screen\n  private enterListeners: Listener[] = [];\n\n  // InteractionHandle to handle tasks around animations\n  private interactionHandle: number | null = null;\n\n  private jumpToIndex = (index: number) => {\n    // If the index changed, we need to trigger a tab switch\n    this.isSwipeGesture.setValue(FALSE);\n    this.nextIndex.setValue(index);\n  };\n\n  private jumpTo = (key: string) => {\n    const { navigationState, keyboardDismissMode, onIndexChange } = this.props;\n\n    const index = navigationState.routes.findIndex(route => route.key === key);\n\n    // A tab switch might occur when we're in the middle of a transition\n    // In that case, the index might be same as before\n    // So we conditionally make the pager to update the position\n    if (navigationState.index === index) {\n      this.jumpToIndex(index);\n    } else {\n      onIndexChange(index);\n\n      // When the index changes, the focused input will no longer be in current tab\n      // So we should dismiss the keyboard\n      if (keyboardDismissMode === 'auto') {\n        Keyboard.dismiss();\n      }\n    }\n  };\n\n  private addListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter':\n        this.enterListeners.push(listener);\n        break;\n    }\n  };\n\n  private removeListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter': {\n        const index = this.enterListeners.indexOf(listener);\n\n        if (index > -1) {\n          this.enterListeners.splice(index, 1);\n        }\n\n        break;\n      }\n    }\n  };\n\n  private handleEnteredIndexChange = ([value]: readonly number[]) => {\n    const index = Math.max(\n      0,\n      Math.min(value, this.props.navigationState.routes.length - 1)\n    );\n\n    this.enterListeners.forEach(listener => listener(index));\n  };\n\n  private transitionTo = (index: Animated.Node<number>) => {\n    const toValue = new Value(0);\n    const frameTime = new Value(0);\n\n    const state = {\n      position: this.progress,\n      time: new Value(0),\n      finished: new Value(FALSE),\n    };\n\n    return block([\n      cond(clockRunning(this.clock), NOOP, [\n        // Animation wasn't running before\n        // Set the initial values and start the clock\n        set(toValue, multiply(index, this.layoutWidth, DIRECTION_RIGHT)),\n        set(frameTime, 0),\n        set(state.time, 0),\n        set(state.finished, FALSE),\n        set(this.index, index),\n      ]),\n      cond(\n        this.isSwipeGesture,\n        // Animate the values with a spring for swipe\n        [\n          cond(\n            not(clockRunning(this.clock)),\n            I18nManager.isRTL\n              ? set(\n                  this.initialVelocityForSpring,\n                  multiply(-1, this.velocityX, this.springVelocityScale)\n                )\n              : set(\n                  this.initialVelocityForSpring,\n                  multiply(this.velocityX, this.springVelocityScale)\n                )\n          ),\n          spring(\n            this.clock,\n            { ...state, velocity: this.initialVelocityForSpring },\n            { ...SPRING_CONFIG, ...this.springConfig, toValue }\n          ),\n        ],\n        // Otherwise use a timing animation for faster switching\n        timing(\n          this.clock,\n          { ...state, frameTime },\n          { ...TIMING_CONFIG, ...this.timingConfig, toValue }\n        )\n      ),\n      cond(not(clockRunning(this.clock)), startClock(this.clock)),\n      cond(state.finished, [\n        // Reset values\n        set(this.isSwipeGesture, FALSE),\n        set(this.gestureX, 0),\n        set(this.velocityX, 0),\n        // When the animation finishes, stop the clock\n        stopClock(this.clock),\n      ]),\n    ]);\n  };\n\n  private handleGestureEvent = event([\n    {\n      nativeEvent: {\n        translationX: this.gestureX,\n        velocityX: this.velocityX,\n        state: this.gestureState,\n      },\n    },\n  ]);\n\n  private extrapolatedPosition = add(\n    this.gestureX,\n    multiply(this.velocityX, this.swipeVelocityImpact)\n  );\n\n  private toggleEnabled = () => {\n    if (this.state.enabled)\n      this.setState({ enabled: false }, () => {\n        this.setState({ enabled: true });\n      });\n  };\n\n  // Cancel gesture if swiping back from the initial tab or forward from the last tab.\n  // Enables parent Pager to pick up the gesture if one exists.\n  private maybeCancel = block([\n    cond(\n      and(\n        this.gesturesEnabled,\n        or(\n          and(\n            eq(this.index, sub(this.routesLength, 1)),\n            lessThan(this.gestureX, 0)\n          ),\n          and(eq(this.index, 0), greaterThan(this.gestureX, 0))\n        )\n      ),\n      set(this.gesturesEnabled, 0)\n    ),\n  ]);\n\n  private translateX = block([\n    onChange(\n      this.gesturesEnabled,\n      cond(\n        not(this.gesturesEnabled),\n        call([this.gesturesEnabled], this.toggleEnabled)\n      )\n    ),\n    onChange(\n      this.index,\n      call([this.index], ([value]) => {\n        this.currentIndexValue = value;\n        // Without this check, the pager can go to an infinite update <-> animate loop for sync updates\n        if (value !== this.props.navigationState.index) {\n          // If the index changed, and previous animation has finished, update state\n          this.props.onIndexChange(value);\n\n          this.pendingIndexValue = value;\n\n          // Force componentDidUpdate to fire, whether user does a setState or not\n          // This allows us to detect when the user drops the update and revert back\n          // It's necessary to make sure that the state stays in sync\n          this.forceUpdate();\n        }\n      })\n    ),\n    onChange(\n      this.position,\n      // Listen to updates in the position to detect when we enter a screen\n      // This is useful for things such as lazy loading when index change will fire too late\n      cond(\n        I18nManager.isRTL\n          ? lessThan(this.gestureX, 0)\n          : greaterThan(this.gestureX, 0),\n        // Based on the direction of the gesture, determine if we're entering the previous or next screen\n        cond(neq(floor(this.position), this.lastEnteredIndex), [\n          set(this.lastEnteredIndex, floor(this.position)),\n          call([floor(this.position)], this.handleEnteredIndexChange),\n        ]),\n        cond(neq(ceil(this.position), this.lastEnteredIndex), [\n          set(this.lastEnteredIndex, ceil(this.position)),\n          call([ceil(this.position)], this.handleEnteredIndexChange),\n        ])\n      )\n    ),\n    onChange(\n      this.isSwiping,\n      // Listen to updates for this value only when it changes\n      // Without `onChange`, this will fire even if the value didn't change\n      // We don't want to call the listeners if the value didn't change\n      [\n        cond(not(this.isSwiping), set(this.gesturesEnabled, 1)),\n        call(\n          [this.isSwiping, this.indexAtSwipeEnd, this.index],\n          ([isSwiping, indexAtSwipeEnd, currentIndex]: readonly number[]) => {\n            const {\n              keyboardDismissMode,\n              onSwipeStart,\n              onSwipeEnd,\n            } = this.props;\n\n            if (isSwiping === TRUE) {\n              onSwipeStart?.();\n              this.interactionHandle = InteractionManager.createInteractionHandle();\n\n              if (keyboardDismissMode === 'auto') {\n                const input = TextInput.State.currentlyFocusedField();\n\n                // When a gesture begins, blur the currently focused input\n                TextInput.State.blurTextInput(input);\n\n                // Store the id of this input so we can refocus it if gesture was cancelled\n                this.previouslyFocusedTextInput = input;\n              } else if (keyboardDismissMode === 'on-drag') {\n                Keyboard.dismiss();\n              }\n            } else {\n              onSwipeEnd?.();\n\n              if (this.interactionHandle !== null) {\n                InteractionManager.clearInteractionHandle(\n                  this.interactionHandle\n                );\n              }\n\n              if (keyboardDismissMode === 'auto') {\n                if (indexAtSwipeEnd === currentIndex) {\n                  // The index didn't change, we should restore the focus of text input\n                  const input = this.previouslyFocusedTextInput;\n\n                  if (input) {\n                    TextInput.State.focusTextInput(input);\n                  }\n                }\n\n                this.previouslyFocusedTextInput = null;\n              }\n            }\n          }\n        ),\n      ]\n    ),\n    onChange(\n      this.nextIndex,\n      cond(neq(this.nextIndex, UNSET), [\n        // Stop any running animations\n        cond(clockRunning(this.clock), stopClock(this.clock)),\n        set(this.gestureX, 0),\n        // Update the index to trigger the transition\n        set(this.index, this.nextIndex),\n        set(this.nextIndex, UNSET),\n      ])\n    ),\n    cond(\n      eq(this.gestureState, State.ACTIVE),\n      [\n        this.maybeCancel,\n        cond(this.isSwiping, NOOP, [\n          // We weren't dragging before, set it to true\n          set(this.isSwiping, TRUE),\n          set(this.isSwipeGesture, TRUE),\n          // Also update the drag offset to the last progress\n          set(this.offsetX, this.progress),\n        ]),\n        // Update progress with previous offset + gesture distance\n        set(\n          this.progress,\n          I18nManager.isRTL\n            ? sub(this.offsetX, this.gestureX)\n            : add(this.offsetX, this.gestureX)\n        ),\n        // Stop animations while we're dragging\n        stopClock(this.clock),\n      ],\n      [\n        set(this.isSwiping, FALSE),\n        set(this.indexAtSwipeEnd, this.index),\n        this.transitionTo(\n          cond(\n            and(\n              // We should consider velocity and gesture distance only when a swipe ends\n              // The gestureX value will be non-zero when swipe has happened\n              // We check against a minimum distance instead of 0 because `activeOffsetX` doesn't seem to be respected on Android\n              // For other factors such as state update, the velocity and gesture distance don't matter\n              greaterThan(abs(this.gestureX), SWIPE_DISTANCE_MINIMUM),\n              greaterThan(\n                abs(this.extrapolatedPosition),\n                divide(this.layoutWidth, 2)\n              )\n            ),\n            // For swipe gesture, to calculate the index, determine direction and add to index\n            // When the user swipes towards the left, we transition to the next tab\n            // When the user swipes towards the right, we transition to the previous tab\n            round(\n              min(\n                max(\n                  0,\n                  sub(\n                    this.index,\n                    cond(\n                      greaterThan(this.extrapolatedPosition, 0),\n                      I18nManager.isRTL ? DIRECTION_RIGHT : DIRECTION_LEFT,\n                      I18nManager.isRTL ? DIRECTION_LEFT : DIRECTION_RIGHT\n                    )\n                  )\n                ),\n                sub(this.routesLength, 1)\n              )\n            ),\n            // Index didn't change/changed due to state update\n            this.index\n          )\n        ),\n      ]\n    ),\n    this.progress,\n  ]);\n\n  private getTranslateX = memoize(\n    (\n      layoutWidth: Animated.Node<number>,\n      routesLength: Animated.Node<number>,\n      translateX: Animated.Node<number>\n    ) =>\n      multiply(\n        // Make sure that the translation doesn't exceed the bounds to prevent overscrolling\n        min(\n          max(\n            multiply(layoutWidth, sub(routesLength, 1), DIRECTION_RIGHT),\n            translateX\n          ),\n          0\n        ),\n        I18nManager.isRTL ? -1 : 1\n      )\n  );\n\n  render() {\n    const {\n      layout,\n      navigationState,\n      swipeEnabled,\n      children,\n      removeClippedSubviews,\n      gestureHandlerProps,\n    } = this.props;\n\n    const translateX = this.getTranslateX(\n      this.layoutWidth,\n      this.routesLength,\n      this.translateX\n    );\n\n    return children({\n      position: this.position,\n      addListener: this.addListener,\n      removeListener: this.removeListener,\n      jumpTo: this.jumpTo,\n      render: children => (\n        <PanGestureHandler\n          ref={this.gestureHandlerRef}\n          simultaneousHandlers={this.state.childPanGestureHandlerRefs}\n          waitFor={this.state.childPanGestureHandlerRefs}\n          enabled={layout.width !== 0 && swipeEnabled && this.state.enabled}\n          onGestureEvent={this.handleGestureEvent}\n          onHandlerStateChange={this.handleGestureEvent}\n          activeOffsetX={[-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM]}\n          failOffsetY={[-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM]}\n          {...gestureHandlerProps}\n        >\n          <Animated.View\n            removeClippedSubviews={removeClippedSubviews}\n            style={[\n              styles.container,\n              layout.width\n                ? {\n                    width: layout.width * navigationState.routes.length,\n                    transform: [{ translateX }] as any,\n                  }\n                : null,\n            ]}\n          >\n            <PagerContext.Provider value={this.providerVal}>\n              {children}\n            </PagerContext.Provider>\n          </Animated.View>\n        </PanGestureHandler>\n      ),\n    });\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'row',\n  },\n});\n"]}